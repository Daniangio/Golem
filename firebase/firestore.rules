rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isPlayer(data) {
      return isSignedIn() &&
        data.keys().hasAny(["players"]) &&
        (data.players is map) && (
        request.auth.uid == data.players.p1 ||
        request.auth.uid == data.players.p2 ||
        request.auth.uid == data.players.p3
      );
    }

    function isInvited(data) {
      return isSignedIn() &&
        (data.invitedUids != null) &&
        (request.auth.uid in data.invitedUids);
    }

    function isPublicOrMissing(data) {
      // Older docs might not have `visibility`; treat as public for reads/joins.
      return !data.keys().hasAny(["visibility"]) || data.visibility == "public";
    }

    function canReadGame(data) {
      return isSignedIn() && (
        isPublicOrMissing(data) ||
        isPlayer(data) ||
        isInvited(data)
      );
    }

    function isJoiningLobby() {
      return (
        resource.data.status == "lobby" &&
        request.resource.data.status == "lobby" &&
        !isPlayer(resource.data) &&
        isPlayer(request.resource.data) &&
        (isPublicOrMissing(resource.data) || isInvited(resource.data))
      );
    }

    // Fallback for legacy lobby docs / client payload differences.
    // Still requires the updater to claim a seat for themselves.
    function isPublicLobbySeatClaim() {
      return isSignedIn() &&
        isPublicOrMissing(resource.data) &&
        resource.data.status == "lobby" &&
        request.resource.data.status == "lobby" &&
        dataIsMap(request.resource.data.players) &&
        (
          request.resource.data.players.p1 == request.auth.uid ||
          request.resource.data.players.p2 == request.auth.uid ||
          request.resource.data.players.p3 == request.auth.uid
        );
    }

    function dataIsMap(v) {
      return v is map;
    }

    match /games/{gameId} {
      allow read: if canReadGame(resource.data);

      // Minimal validation: creator must match, game starts in lobby.
      allow create: if isSignedIn()
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.status == "lobby"
        && request.resource.data.keys().hasAll(["visibility"])
        && (request.resource.data.visibility in ["public", "private"]);

      // Players can update freely (game logic is enforced client-side in v0).
      // Non-players can only perform a restricted "join lobby" update.
      allow update: if isPlayer(resource.data) || isJoiningLobby() || isPublicLobbySeatClaim();

      // Allow delete only by creator.
      allow delete: if isSignedIn() && request.auth.uid == resource.data.createdBy;
    }

    match /users/{userId} {
      allow read: if isSignedIn() && request.auth.uid == userId;
      allow create, update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if false;
    }
  }
}
