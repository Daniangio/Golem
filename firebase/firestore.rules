rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isPlayer(data) {
      return isSignedIn() && (
        request.auth.uid == data.players.p1 ||
        request.auth.uid == data.players.p2 ||
        request.auth.uid == data.players.p3
      );
    }

    function isInvited(data) {
      return isSignedIn() &&
        (data.invitedUids != null) &&
        (request.auth.uid in data.invitedUids);
    }

    function isPublicOrMissing(data) {
      // Older docs might not have `visibility`; treat as public for reads/joins.
      return !data.keys().hasAny(["visibility"]) || data.visibility == "public";
    }

    function canReadGame(data) {
      return isSignedIn() && (
        isPublicOrMissing(data) ||
        isPlayer(data) ||
        isInvited(data)
      );
    }

    function mySeatCount(players) {
      return (players.p1 == request.auth.uid ? 1 : 0) +
        (players.p2 == request.auth.uid ? 1 : 0) +
        (players.p3 == request.auth.uid ? 1 : 0);
    }

    function joinOnlyAddsSelf(oldPlayers, newPlayers) {
      return (
        (
          ((oldPlayers.p1 == null) && (newPlayers.p1 == null || newPlayers.p1 == request.auth.uid)) ||
          ((oldPlayers.p1 != null) && (newPlayers.p1 == oldPlayers.p1))
        ) &&
        (
          ((oldPlayers.p2 == null) && (newPlayers.p2 == null || newPlayers.p2 == request.auth.uid)) ||
          ((oldPlayers.p2 != null) && (newPlayers.p2 == oldPlayers.p2))
        ) &&
        (
          ((oldPlayers.p3 == null) && (newPlayers.p3 == null || newPlayers.p3 == request.auth.uid)) ||
          ((oldPlayers.p3 != null) && (newPlayers.p3 == oldPlayers.p3))
        )
      );
    }

    function joinChangesOnlyAllowedFields() {
      // For non-players joining a lobby: restrict top-level changed keys.
      return request.resource.data.diff(resource.data).changedKeys().hasOnly([
        "players",
        "playerNames",
        "playerUids",
        "invitedUids",
        "updatedAt"
      ]);
    }

    function isJoiningLobby() {
      return (
        resource.data.status == "lobby" &&
        request.resource.data.status == "lobby" &&
        !isPlayer(resource.data) &&
        isPlayer(request.resource.data) &&
        (isPublicOrMissing(resource.data) || isInvited(resource.data)) &&
        mySeatCount(request.resource.data.players) == 1 &&
        joinOnlyAddsSelf(resource.data.players, request.resource.data.players) &&
        request.auth.uid in request.resource.data.playerUids &&
        request.resource.data.playerUids.size() <= 3 &&
        joinChangesOnlyAllowedFields()
      );
    }

    match /games/{gameId} {
      allow read: if canReadGame(resource.data);

      // Minimal validation: creator must match, game starts in lobby.
      allow create: if isSignedIn()
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.status == "lobby"
        && request.resource.data.keys().hasAll(["visibility"])
        && (request.resource.data.visibility in ["public", "private"]);

      // Players can update freely (game logic is enforced client-side in v0).
      // Non-players can only perform a restricted "join lobby" update.
      allow update: if isPlayer(resource.data) || isJoiningLobby();

      // Allow delete only by creator.
      allow delete: if isSignedIn() && request.auth.uid == resource.data.createdBy;
    }

    match /users/{userId} {
      allow read: if isSignedIn() && request.auth.uid == userId;
      allow create, update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if false;
    }
  }
}
